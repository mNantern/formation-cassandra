<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Formation Cassandra - Xebia</title>

		<meta name="description" content="Formation Cassandra by Xebia">
		<meta name="author" content="Matthieu Nantern">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/moon.css" id="theme">
		<link rel="stylesheet" href="css/gh-fork-ribbon.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">
			<div class='footer'>
    			<img src="media/byXebia.png"/>
  			</div>

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
					<h1>Formation Cassandra</h1>
					<h3>Xebia</h3>
					<p class="center">
						<small>Created by <a href="http://nantern.fr">Matthieu Nantern</a> / <a href="http://twitter.com/mnantern">@mnantern</a></small>
					</p>
				</section>

				<section>
					<h2>Le programme !</h2>
					<ol>
						<li>Tour de table</li>
						<li>Introduction</li>
						<li>Architecture de Cassandra</li>
						<li>Installation et configuration</li>
						<li>Modèle de données</li>
						<li>Le driver Java</li>
						<li>Administration Cassandra</li>
					</ol>
				</section>

				<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
					<h2>Tour de table</h2>
					<ul>
						<li>Qui suis-je ?</li>
						<li>Trois attentes sur la formation</li>
					</ul>
				</section>

				<section>
					<section>
						<h1>Introduction</h1>
					</section>

					<section>
						<h3>Cassandra et les bases NoSQL</h3>
						<p class="fragment">NoSQL ?</p>
						<blockquote cite="https://www.mongodb.com/nosql-explained" class="fragment">
							&ldquo;NoSQL (Not only SQL en anglais) désigne une catégorie de systèmes de gestion de base de données qui n'est plus fondée sur l'architecture classique des bases relationnelles. Il renonce aux fonctionnalités classiques des SGBD relationnels au profit de la simplicité. Les performances restent bonnes en multipliant simplement le nombre de serveurs, solution raisonnable avec la baisse des coûts.&rdquo;
						</blockquote>
					</section>

					<section>
						<h3>Les bases NoSQL</h3>
						<p class="fragment roll-in">
		                    <img src="media/cassandra.jpg"/>
		                    <img src="media/mongo.png"/>
		                    <img src="media/hbase.png"/>
		                    <img src="media/redis.jpg"/>
		                    <img src="media/couchbase.jpg"/>
		                    <img src="media/neo4j.png"/>
		                    <strong>...</strong>
		                </p>
					</section>

					<section>
						<h3>Les bases NoSQL</h3>
						<p>Les bases NoSQL se classent en quatre catégories:</p>
						<ul>
							<li><span class='highlight'>Colonnes:</span> Cassandra, HBase</li>
							<li><span class='highlight'>Documents:</span> MongoDB, ElasticSearch</li>
							<li><span class='highlight'>Clés/valeurs:</span> Redis, Riak, Couchbase</li>
							<li><span class='highlight'>Graph:</span> Neo4j</li>
						</ul>
					</section>

					<section>
						<h3>Un peu de théorie: le théorème de CAP</h3>
						<p>Le théorème CAP également connu sous le nom de théorème de Brewer montre qu’il est impossible pour un système distribué de satisfaire de manière simultanée les trois contraintes suivantes :</p>
						<ul>
							<li><span class='highlight'>Cohérence (“Consistency”) :</span> tous les noeuds du système voient la même donnée au même moment;</li>
							<li><span class='highlight'>Disponibilité (“Availability”) :</span> chaque requête recevra une réponse (que cela soit un succès ou un échec);</li>
							<li><span class='highlight'>Résistance à la partition (“Partition tolerance”) :</span>  le système continue de fonctionner malgré des défaillances pouvant aller jusqu’à la séparation du cluster en sous-système.</li>
						</ul>
					</section>

					<section>
						<img src="media/visual_cap.png"/>
					</section>

					<section>
						<h3>Cassandra</h3>
						<ul>
							<li><b>Technologies de base:</b>
								<ul>
									<li><span class='highlight'>Google BigTable :</span> modèle de stockage</li>
									<li><span class='highlight'>Amazon Dynamo :</span> modèle de réplication</li>
								</ul>
							</li>
							<li>Historique:
								<ul>
									<li><span class='highlight'>2008 :</span> libération par Facebook</li>
									<li><span class='highlight'>2010 :</span> Top Level Project Apache</li>
									<li><span class='highlight'>Octobre 2011 :</span> version 1.0</li>
									<li><span class='highlight'>Septembre 2013 :</span> version 2.0</li>
									<li><span class='highlight'>Décembre 2015 :</span> version 3.x</li>
								</ul>
							</li>
						</ul>
					</section>

					<section>
						<h3>Quand utiliser Cassandra ?</h3>
						<ul>
							<li>Pas de SPOF (Single point of failure)</li>
							<li>Réplication native entre serveurs et datacenters</li>
							<li>Scalabilité linéaire</li>
							<li>Beaucoup d'écriture et de lecture</li>
						</ul>
					</section>

					<section>
						<h3>Quand ne pas utiliser Cassandra ?</h3>
						<ul>
							<li>Besoin de transaction avec rollback</li>
							<li>??</li>
						</ul>
					</section>

					<section>
						<h3>Les cas d'utilisation classiques de Cassandra</h3>
						<ul>
							<li><b>Time series / IOT</b></li>
							<li><b>Messaging</b></li>
							<li><b>Recommandation</b></li>
							<li><b>Catalogue produit / Playlists</b></li>
						</ul>
						<p class="center"><a href="http://www.planetcassandra.org/apache-cassandra-use-cases/">liste de cas d'utilisation C*</a></p>
					</section>
				</section>

				<section>
					<section>
						<h1>Architecture de Cassandra</h1>
					</section>

					<section>
						<h3>Le cluster</h3>
						<img src="media/Cassandra_architecture.png"/>
					</section>

					<section>
						<h3>Le coordinator</h3>
						<img class="stretch" src="media/architecture_coordinator.png"/>
					</section>

					<section>
						<h3>Le partitionnement</h3>
						<img class="stretch" src="media/architecture_partinionnement.png"/>
					</section>

					<section>
						<h3>La réplication (1/2)</h3>
						<p>Deux éléments influent sur la réplication:</p>
						<ol>
							<li><span class='highlight'>Le facteur de réplication</span>: indique le nombre de fois qu'une donnée doit être répliquée sur le cluster</li>
							<li><span class='highlight'>La stratégie de réplication</span>: indique quelle machine doit stocker la donnée</li>
						</ol>
						<pre><code data-trim contenteditable>
	CREATE KEYSPACE Demo
WITH REPLICATION = {
	'class' : 'NetworkTopologyStrategy',
	'dc-east' : 2,
	'dc-west' : 3
};
							</code></pre>
					</section>

					<section>
						<h3>La réplication (2/2)</h3>
						<img class="stretch" src="media/architecture_replication.png"/>
					</section>

					<section>
						<h3>La cohérence</h3>
						<p>La cohérence d'une requête définit le nombre de noeuds devant répondre à une requête avant que celle-ci ne soit considérée comme terminée par le cluster Cassandra.</p>
						<p>Dans le cadre d'<span class='highlight'>une lecture</span> cela définit le nombre de noeud devant envoyer la copie la plus récente de la donnée.</p>
						<p>Dans le cadre d'<span class='highlight'>une écriture</span> cela définit le nombre  de noeud devant confirmer avoir écrit la donnée.</p>
						<p>La cohérence est choisie par requête dans Cassandra.</p>
					</section>

					<section>
						<h3>Les différents niveaux de cohérence</h3>
						<table>
							<thead>
								<tr>
									<th>Nom</th>
									<th>Description</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td><span class='highlight'>ONE</span></td>
									<td>Attend la réponse d'une noeud avant de répondre au client.</td>
								<tr>
								<tr>
									<td><span class='highlight'>QUORUM</span></td>
									<td>Attend la réponse de RF/2+1 avant de répondre au client.</td>
								<tr>
								<tr>
									<td><span class='highlight'>ALL</span></td>
									<td>Attend la réponse de tous les noeuds avant de répondre au client.</td>
								<tr>
							</tbody>
						</table>
					</section>

					<section>
						<h3>La cohérence en action</h3>
						<p>RF = <span class='highlight'>3</span>, Write <span class='highlight'>ONE</span>, Read <span class='highlight'>ONE</span></p>
						<img class="stretch" src="media/architecture_consistence1.png"/>
					</section>

					<section>
						<h3>La cohérence en action</h3>
						<p>RF = <span class='highlight'>3</span>, Write <span class='highlight'>ONE</span>, Read <span class='highlight'>QUORUM</span></p>
						<img class="stretch" src="media/architecture_consistence2.png"/>
					</section>

					<section>
						<h3>La cohérence en action</h3>
						<p>RF = <span class='highlight'>3</span>, Write <span class='highlight'>ONE</span>, Read <span class='highlight'>ALL</span></p>
						<img class="stretch" src="media/architecture_consistence3.png"/>
					</section>

					<section>
						<h3>La cohérence en action</h3>
						<p>RF = <span class='highlight'>3</span>, Write <span class='highlight'>QUORUM</span>, Read <span class='highlight'>QUORUM</span></p>
						<img class="stretch" src="media/architecture_consistence4.png"/>
					</section>

					<section>
						<h3>Les usages des niveaux de cohérence (1/2)</h3>
						<table>
							<thead>
								<tr>
									<th>Nom</th>
									<th>Usage</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td><span class='highlight'>ONE</span></td>
									<td>Rapide. Très bonne disponibilité. Ne lit pas forcément la toute dernière valeur.</td>
								<tr>
								<tr>
									<td><span class='highlight'>QUORUM</span></td>
									<td>Bon compromis entre la cohérence et la rapidité.</td>
								<tr>
								<tr>
									<td><span class='highlight'>ALL</span></td>
									<td>Plus haut niveau de cohérence. Très faible disponibilité.</td>
								<tr>
							</tbody>
						</table>
					</section>

					<section>
						<h3>Les usages des niveaux de cohérence (2/2)</h3>
						<p>Les deux niveaux les plus couramment utilisés sont:</p>
						<ul>
							<li><span class='highlight'>ONE read + ONE write:</span> rapide et fonctionne même avec RF - 1 noeuds indisponibles</li>
							<li><span class='highlight'>QUORUM read + QUORUM write:</span> consistent. On lit toujours la dernière valeur insérée.</li>
						</ul>
					</section>

					<section>
						<h3>Cassandra Write Path</h3>
						<img class="stretch" src="media/write-path.png"/>
					</section>

					<section>
						<h3>Cassandra Read Path</h3>
						<img class="stretch" src="media/read-path.png"/>
					</section>

					<section>
						<h3>La scalabilité</h3>
						<img class="stretch" src="media/scale.png"/>
					</section>

				</section>

				<section>
					<section>
						<h1>Installation et configuration</h1>
					</section>

					<section>
						<h3>Installation de C*</h3>
						<h6>Prérequis</h6>
						<ul>
							<li>Oracle JDK 1.8 64 bits</li>
							<li>Configurer JAVA_HOME</li>
							<li>Sélectionner sa distribution C*:
								<ul>
									<li><a href="http://cassandra.apache.org/download/">Apache Cassandra</a></li>
									<li><a href="http://www.planetcassandra.org/cassandra/">Datastax Community Edition</a></li>
									<li><a href="https://academy.datastax.com/downloads?destination=downloads&dxt=DX">Datastax Enterprise</a></li>
								</ul>
							</li>
						</ul>
					</section>

					<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
						<h3>Installation de C*</h3>
						<h6>Clonner le dépôt présent à l'adresse suivante et réaliser ce qui est indiqué dans le fichier <span class='highlight'>exercices/01_installation.md</span></h6>
						<pre><code data-trim contenteditable>
						git clone https://github.com/mNantern/formation-cassandra.git
						</code></pre>
					</section>

					<section>
						<h3>Installation de C*</h3>
						<h6>Fichiers de configuration</h6>
						<ul>
							<li><span class='highlight'>cassandra.yaml:</span> fichier principal de configuration</li>
							<li><span class='highlight'>cassandra-env.sh:</span> configuration de l'environnement Java (heap size,...)</li>
							<li><span class='highlight'>logback.xml:</span> configuration des logs</li>
						</ul>
						<h6>Le fichier cassandra.yaml, principales propriétés</h6>
						<ul>
							<li><span class='highlight'>cluster_name:</span> toutes les machines d'un cluster doivent avoir le même nom</li>
							<li><span class='highlight'>listen_address:</span> le port sur lequel C* écoute les autres noeuds</li>
						</ul>
					</section>

					<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
						<h3>Installation de C*</h3>
						<h6>On démarre !</h6>
						<ol>
							<li>Vérifier le status du service Cassandra
							<pre><code data-trim contenteditable>
								sudo service cassandra status
							</code></pre>
							</li>
							<li>Visualiser les logs de C*
							<pre><code data-trim contenteditable>
								ls /var/log/cassandra/
							</code></pre>
							</li>
							<li>Arrêter le service Cassandra
							<pre><code data-trim contenteditable>
								sudo service cassandra stop
							</code></pre>
							</li>
							<li>Démarrer le service Cassandra
							<pre><code data-trim contenteditable>
								sudo service cassandra start
							</code></pre>
							</li>
						</ol>
					</section>

					<section>
						<h3>Les outils Cassandra</h3>
						<h6>nodetool</h6>
						<p>Nodetool est le couteau suisse de Cassandra. Il permet d'obtenir des informations et de gérer un cluster de machines. Les commandes les plus couramment utilisées sont:</p>
						<ul>
							<li><span class='highlight'>status:</span> fournit des informations sur le cluster (état, charge, ID)</li>
							<li><span class='highlight'>info:</span>  fournit des informations sur la machine locale (mémoire, espace disque,...)</li>
							<li><span class='highlight'>ring:</span> affiche un résumé pour chaque noeud dans le cluster. Permet de repérer les machines déséquilibrées. Privilégier plutôt status et info</li>
						</ul>
					</section>

					<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
						<h3>Nodetool</h3>
						<ol>
							<li>Explorer la liste des commandes de nodetool
							<pre><code data-trim contenteditable>
								nodetool help
							</code></pre>
							</li>
							<li>Obtenir de l'aide sur une commande
							<pre><code data-trim contenteditable>
								nodetool help &lt;command&gt;
							</code></pre>
							</li>
							<li>Tester les commandes status,info et ring</li>
						</ol>
					</section>

					<section>
						<h3>Les outils Cassandra</h3>
						<h6>cqlsh</h6>
						<p>CQLSH est un shell interactif permettant de tester des commandes dans le langage CQL (Cassandra Query Language). Il offre également d'autres commandes uniquement disponibles dans le shell:</p>
						<ul>
							<li><span class='highlight'>COPY:</span> import ou export les données au format CSV</li>
							<li><span class='highlight'>DESCRIBE:</span> fournit des informations sur le cluster, les keyspaces ou les tables</li>
							<li><span class='highlight'>TRACING:</span> active ou désactive le tracing des requêtes</li>
							<li><span class='highlight'>SOURCE:</span> exécute un fichier contenant des requêtes CQL</li>
							<li><a href="http://docs.datastax.com/en/cql/3.3/cql/cql_reference/cqlshCommandsTOC.html">Et d'autres...</a></li>
						</ul>
					</section>

					<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
						<h3>On créé notre premier keyspace !</h3>
						<ol>
							<li>Affichons la liste des keyspaces (Tab pour l'auto-complétion)
							<pre><code data-trim contenteditable>
								cqlsh> DESCRIBE KEYSPACES;
							</code></pre>
							</li>
							<li>Création d'un keyspace:
							<pre><code data-trim contenteditable>
	CREATE KEYSPACE cassandra-iot
WITH REPLICATION = {
	'class' : 'SimpleStrategy',
	'replication_factor' : 1
};
							</code></pre>
							</li>
							<li>Afficher à nouveau la liste des keyspaces et le détail pour notre keyspace cassandra-iot</li>
						</ol>
					</section>

					<section>
						<h3>Les outils Cassandra</h3>
						<h6>DevCenter</h6>
						<p>DevCenter est un IDE (basé sur Eclipse) permettant de visualiser les tables et d'exécuter des commandes CQL avec auto-complétion, sauvegarder des requêtes et maintenir plusieurs connections simultanées</p>
					</section>

					<section>
						<img class="stretch" src="media/devcenter.jpg"/>
					</section>
				</section>


				<section>
					<section>
						<h1>Modèle de données</h1>
					</section>
					<section>
						<h3>Principes de modélisations des données</h3>
						<p>Construire un schéma de base relationnelle passe bien souvent par la description des types d'objets, des attributs et des liens entre les tables. Les requêtes arrivent ensuite.</p>
						<p>Pour Cassandra il est primordial de <span class='highlight'>commencer par les requêtes</span>. Les tables sont ensuites construites pour supporter ces requêtes. Cela permet d'obtenir un modèle répondant rapidement aux requêtes et scalant correctement.</p>
					</section>
					<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
						<h3>L'application Cassandra-iot</h3>
						<p>Nous allons développer la partie back d'une application destinée à gérer des objets connectés.</p>
						<p>Cette application devra être capable de gérer les données provenant de millions d'objets de manière performante et sans interruption de service.</p>
						<p>Notre application devra être capable de déclarer des familles d'objets connectés, de créer un objet connecté, d'envoyer des données sur cet objet et de gérer des comptes utilisateurs.</p>
					</section>
					<section>
						<h3>Keyspaces</h3>
						<ul>
							<li>Niveau le plus élevé</li>
							<li>Contient des tables</li>
							<li>
								Le paramètre de réplication est obligatoire:
								<pre><code data-trim contenteditable>
		CREATE KEYSPACE cassandra-iot
WITH REPLICATION = {
	'class' : 'SimpleStrategy',
	'replication_factor' : 1
};
								</code></pre>
							</li>
							<li>
								Utiliser le mot clé <span class='highlight'>USE</span> pour changer de keyspace:
								<pre><code data-trim contenteditable>
		USE cassandra-iot;
								</code></pre>
							</li>
						</ul>
					</section>
					<section>
						<h3>Les tables</h3>
						<p>Les keyspaces contiennent des tables.</p>
						<p>Les tables contiennent les données.</p>
						<pre><code data-trim contenteditable>
CREATE TABLE users (
	id UUID PRIMARY KEY,
	first_name TEXT,
	last_name TEXT,
	email TEXT
);
						</code></pre>
					</section>
					<section>
						<h3>Les types de données, épisode 1</h3>
						<ul>
							<li><span class='highlight'>text:</span> une chaine de caractères encodée en UTF8, équivalent à varchar</li>
							<li><span class='highlight'>uuid:</span> un identifiant unique (UUID de type 4)</li>
							<li><span class='highlight'>int:</span> un entier sur 32 bits signé</li>
							<li><span class='highlight'>timeuuid:</span> un identifiant unique conteant un timestamp (UUID de type 1).</li>
							<li><span class='highlight'>timestamp:</span> millisecondes depuis Epoch</li>
						</ul>
					</section>

					<section>
						<h3>Lire des données</h3>
					</section>

					<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
						<h3>Première table et premières requêtes</h3>
						<p>
							Réaliser l'exercice <a href="https://github.com/mNantern/formation-cassandra/blob/master/exercices/02_premieres_requetes.md">exercices/02_premieres_requetes.md</a>
						</p>
					</section>

					<section>
						<h3>Importance de la clé de partitionnement</h3>
						<p>Dans une base de données relationnelle son absence implique un "full table scan".</p>
						<p>Avec C* cela implique un <span class='highlight'>"full cluster scan"</span>.</p>
						<img src="media/kllm.gif"/>
						<h6>Comment fait-on alors ?</h6>
					</section>

					<section>
						<h3>Index secondaire</h3>
						<p>Il existe dans Cassandra un mécanisme d'index secondaires permettant de réaliser ensuite des requêtes sur cet index sans avoir besoin de passer la clé de partitionnement.</p>
						<p>
							<span class='highlight'><b>=> Retour à l'exercice !</b></span>
						</p>
					</section>

					<section>
						<h3>Index secondaire</h3>
						<h6>Quand ne faut-il pas les utiliser ?</h6>
						<ul>
							<li>Sur les colonnes avec une grande cardinalité (un id ou un email par exemple)</li>
							<li>Sur les colonnes avec une très faible cardinalité (un boolean par exemple)</li>
							<li>Sur les tables contenant une grande quantité de données: les index secondaires sont locaux à chaque machine du cluster</li>
							<li>Sur les colonnes où les données sont régulièrement supprimées</li>
						</ul>
					</section>

					<section>
						<h3>Index secondaire</h3>
						<h6>Quand faut-il les utiliser ?</h6>
						<ul>
							<li>Sur des colonnes contenant peu de données et une cardinalité moyenne</li>
							<li>Si la requête est restreinte par la clé de partitionnement</li>
						</ul>
						<p>
							<span class='highlight'>Le plus simple est d'oublier les index secondaires.</span>
						</p>
					</section>

					<section>
						<h3>Comment faire alors ?</h3>
						<p>
							La bonne solution dans notre cas est d'utiliser l'email en tant que clé primaire d'une autre table. La clé primaire est globale au cluster au contraire d'un index secondaire.
						</p>
						<p>
							Dupliquer les données dans C* ne pose aucun problème, la base est conçue pour cela. Ecrire des données est efficace, utiliser un index secondaire ne l'est pas.
						</p>
						<p>
							<span class='highlight'><b>=> Retour à l'exercice !</b></span>
						</p>
					</section>

					<section>
						<h3>Remarques</h3>
						<p>
							La cohérence entre nos tables 'users' et 'users_by_email' doit être <span class='highlight'>assurée applicativement</span> lors des insertions/mises à jour et des suppressions. Il est important de ne <span class='highlight'>dénormaliser que les données qui changent peu</span>.
						</p>
						<p>
							Si la duplication des données pose problème (les données sont très volumineuses) ou que les données changent très régulièrement alors il peut être plus performant de ne <span class='highlight'>conserver dans la table 'users_by_email' que l'email et l'id</span> et de faire ensuite une nouvelle requête à C* pour obtenir les autres informations de la table 'users'.
						</p>
					</section>

					<section>
						<h3>Insérer des données</h3>
					</section>

					<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
						<h3>Les insertions</h3>
						<p>
							Réaliser l'exercice <a href="https://github.com/mNantern/formation-cassandra/blob/master/exercices/03_inserer_donnees.md">exercices/03_inserer_donnees.md</a>
						</p>
					</section>

					<section>
						<h3>Upsert</h3>
						<p>Qu'est ce qu'il vient de se passer ?</p>
						<p>Dans C* <span class='highlight'>le dernier qui écrit a raison</span>: LWW (Last Write Wins)</p>
						<p>
							<span class='highlight'><b>=> Retour à l'exercice !</b></span>
						</p>
					</section>

					<section>
						<h3>Quelle est la différence ?</h3>
						<p class="fragment">Il n'y en a pas.</p>
						<p class="fragment">Enfin presque: les compteurs</p>
						<p class="fragment">Mais c'est une autre histoire.</p>
					</section>

					<section>
						<h3>Le problème</h3>
						<img src="media/lwt.png"/>
					</section>

					<section>
						<div class="github-fork-ribbon right-top" title="v2.0"></div>
						<h3>La solution, les LWT</h3>
						<h6>LightWeight Transaction</h6>
						<p>Se base sur un algorithme de consensus distribué, Paxos.</p>
						<p>Ce mécanisme ajoute le mot clé "IF" dans CQL et permet de réaliser des requêtes de type "IF NOT EXISTS" ou "IF column1=value".</p>
						<p>Ce processus est quatre fois plus couteux qu'une insertion classique. Il faut donc l'utiliser uniquement dans les cas où il est nécessaire.</p>
						<p>
							<span class='highlight'><b>=> Retour à l'exercice !</b></span>
						</p>
					</section>

					<section>
						<h3>La clé primaire</h3>
					</section>
					<section>
						<h3>Clé primaire</h3>
						<p>
							Jusqu'à présent nous avons vu des tables avec des clés primaires simples. Mais il est possible de créer des clés primaires bien plus évoluées afin de modéliser au mieux les requêtes que l'on a besoin d'exécuter.
						</p>
						<p>
							Quelques éléments de vocabulaire:
						</p>
						<ul>
							<li><span class='highlight'>clé de partitionnement:</span> la "première colonne" de notre clé primaire</li>
							<li><span class='highlight'>colonne de clustering:</span> toutes les autres colonnes composant la clé primaire</li>
							<li><span class='highlight'>clé de partitionnement composée:</span> une clé de partitionnement composée de plusieurs colonnes</li>
						</ul>
					</section>
					<section>
						<h3>Clé de partitionement</h3>
						<p>C'est un élément central dans le design de nos tables. Cette clé indique <span class='highlight'>sur quelle machine de notre cluster les données sont stockées</span>.</p>
						<p>
							La clé de partitionnement étant obligatoire dans les requêtes réalisées sur C*, il est important de la créer afin qu'elle soit la plus proche possible des requêtes que l'on souhaite effectuer sur notre cluster.
						</p>
					</section>
					<section data-transition="slide" data-background="#4d7e65" data-background-transition="zoom">
						<h3>Le design de la clé primaire</h3>
						<p>
							Réaliser l'exercice <a href="https://github.com/mNantern/formation-cassandra/blob/master/exercices/04_cle_primaire.md">exercices/04_cle_primaire.md</a>
						</p>
					</section>
					<section>
						<h3>Stockage physique des données</h3>
						<img src="media/Cassandra_physical_storage1.png"/>
					</section>
					<section>
						<h3>Stockage des partitions</h3>
						<ul>
							<li>
								Les <span class='highlight'>partitions sont distribuées sur les différents noeuds</span> du cluster
							</li>
							<li>
								Un algorithme de hash permet de déterminer rapidement quel noeud possède la partition recherchée
							</li>
							<li>
								Il est possible de <span class='highlight'>faire un 'WHERE' sur la clé de partition</span> mais le faire sur une autre colonne impliquerai de scanner toutes les partitions sur tous les noeuds.
							</li>
						</ul>
						<img src="media/kllm.gif"/>
					</section>
					<section>
						<h3>Clustering columns</h3>
						<p>Il est possible d'ajouter à la clé de partitionnement d'autres colonnes appelées "Colonne de clustering".</p>
						<p>Le clustering est le processus qui trie les données au sein d'une même partition. Comme les données sont triées sur disque il est extrêmement performant de récupérer une partie de la partition (lecture séquentielle sur le disque)</p>
					</section>
					<section>
						<h3>Clustering columns</h3>
						<p>On peut alors, grâce au clustering columns réaliser des requêtes de ce type:</p>
						<pre><code data-trim contenteditable>
SELECT * FROM data
  WHERE partition_key=value_partition_key
  AND clustering_column1=value1
						</code></pre>
						<p>
							Voir même des "range requests":
						</p>
						<pre><code data-trim contenteditable>
SELECT * FROM data
  WHERE partition_key=value_partition_key
  AND clustering_column1 > value1
						</code></pre>
						<p>
							<span class='highlight'><b>=> Retour à l'exercice !</b></span>
						</p>
					</section>
					<section>
						<h3>Stockage physique des données 2</h3>
						<pre><code data-trim contenteditable>
CREATE TABLE data (
  id UUID,
  year TEXT,
  value TEXT,
  event_time timestamp,
  PRIMARY KEY (year,id)
);
						</code></pre>
						<table>
							<thead>
								<tr>
									<th>year</th>
									<th>id</th>
									<th>value</th>
									<th>event_time</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>2016</td>
									<td>1</td>
									<td>7</td>
									<td>2016-02-19T17:13:21Z</td>
								</tr>
								<tr>
									<td>2016</td>
									<td>2</td>
									<td>18</td>
									<td>2016-02-25T17:13:21Z</td>
								</tr>
								<tr>
									<td>2015</td>
									<td>3</td>
									<td>2</td>
									<td>2015-12-19T07:13:21Z</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>Stockage physique des données 2</h3>
						<img src="media/Cassandra_physical_storage2.png"/>
					</section>
					<section>
						<h3>Limiter la taille des partitions</h3>
						<p>
							Le nombre maximal de valeurs par partition est 2 milliards en théorie. La partition doit également tenir sur le disque d'un seul noeud.
						</p>
						<p>
							En pratique il faut éviter de dépasser quelques centaines de milliers de valeur par partition et quelques centaines de Mo.
						</p>
						<p>
							<span class='highlight'><b>=> Retour à l'exercice !</b></span>
						</p>
					</section>
					<section>
						<h3>Stockage physique des données 3</h3>
						<pre><code data-trim contenteditable>
CREATE TABLE data (
	id UUID,
	smartphone_id UUID,
	year TEXT,
	value TEXT,
	event_time timestamp,
	PRIMARY KEY ((smartphone_id,year),id)
);
						</code></pre>
						<table>
							<thead>
								<tr>
									<th>smartphone_id</th>
									<th>year</th>
									<th>id</th>
									<th>value</th>
									<th>event_time</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>SAMSUNG_1567</td>
									<td>2016</td>
									<td>1</td>
									<td>7</td>
									<td>2016-02-19T17:13:21Z</td>
								</tr>
								<tr>
									<td>SAMSUNG_1567</td>
									<td>2016</td>
									<td>2</td>
									<td>18</td>
									<td>2016-02-25T17:13:21Z</td>
								</tr>
								<tr>
									<td>SAMSUNG_1567</td>
									<td>2015</td>
									<td>3</td>
									<td>2</td>
									<td>2015-12-19T07:13:21Z</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>Stockage physique des données 3</h3>
						<img src="media/Cassandra_physical_storage3.png"/>
					</section>
					<section>
						<h3>Requêtes</h3>
						<ul>
							<li>
								<span class='highlight'>Sur la clé de partitionnement:</span> = et IN
							</li>
							<li>
								<span class='highlight'>Sur les colonnes de clustering:</span> <, <=, >, >= et IN
							</li>
						</ul>
						<br />
						<br />
						<h3>Ordre</h3>
						<ul>
							<li>
								<span class='highlight'>sur la clé de partitionnement:</span> aucun ordre
							</li>
							<li>
								<span class='highlight'>Sur les colonnes de clustering:</span> ordonné en fonction de l'ordre de déclaration des colonnes
							</li>
						</ul>
					</section>
					<section>
						<h3>Modélisation des relations</h3>
						<ul>
							<li>
								<span class='highlight'>Relation 1-1:</span> une relation 1-1 peut être modélisée en utilisant une simple clé primaire
							</li>
							<li>
								<span class='highlight'>Relation 1-n:</span> une relation 1-n peut être modélisée en utilisant une clé primaire composée d'une partition key et d'au moins une clustering key
							</li>
							<li>
								<span class='highlight'>Relation m-n:</span> une relation n-n peut être modélisée en utilisant une clé primaire composée d'une clé de partition composée et d'au moins une clustering key
							</li>
						</ul>
					</section>

					<section>
						<h3>Modélisation avancée</h3>
					</section>
					<section>
						<h3>Les collections</h3>
						<p>
							Depuis la version 1.2 de C* il est possible de créer des colonnes de type collection (list, set et map).
						</p>
						<p>
							Les collections ne peuvent pas être découpée. Cassandra lira la collection en entier. De ce fait il ne faut pas dépasser quelques milliers d'éléments par collection.
						</p>
						<p>
							Il n'est pas possible d'inclure une collection dans une collection.
						</p>
					</section>
					<section>
						<div class="github-fork-ribbon right-top" title="v2.1"></div>
						<h3>Les compteurs</h3>
						<p>
							Il est possible de stocker un compteur qui compte un nombre d'occurence.
						</p>
						<p>
							Attention, si une table a une colonne de type counter, toutes les colonnes non-"counter" doivent faire partie de la clé primaire.
						</p>
						<pre><code data-trim contenteditable>
CREATE TABLE devicesByUser (
  user_id UUID,
  number_devices COUNTER,
  PRIMARY KEY (user_id)
);

UPDATE devicesByUser SET number_devices = number_devices + 2
  WHERE user_id = 1;
						</code></pre>
					</section>
					<section>
						<h3>TTL: Time To Live</h3>
						<p>
							Il est possible d'ajouter une durée de vie à une donnée (ligne ou colonne individuelle) au moment de l'insertion. Cassandra se chargera alors de supprimer cette donnée une fois la durée écoulée.
						</p>
						<pre><code data-trim contenteditable>
INSERT INTO data (id, event_time, value)
  VALUES ('1','2015-12-19T07:13:21Z',34) USING TTL 3600;

UPDATE data USING TTL 30 SET value=12 WHERE id='1';
						</code></pre>
					</section>
					<section>
						<h3>Static</h3>
						<p>
							Une colonne statique est une colonne qui est partagée par toutes les lignes de la même partition.
						</p>
						<pre><code data-trim contenteditable>
CREATE TABLE t (
  k text,
  s text STATIC,
  i int,
  PRIMARY KEY (k, i)
);

INSERT INTO t (k, s, i) VALUES ('k', 'I''m shared', 1);
INSERT INTO t (k, s, i) VALUES ('k', 'I''m still shared', 2);
SELECT * FROM t;
						</code></pre>
						<p>
							Et le résultat:
						</p>
						<table>
							<thead>
								<tr>
									<th>k</th>
									<th>s</th>
									<th>i</th>
								</tr>
							</thead>
							<tbody>
								<tr>
									<td>k</td>
									<td>I'm still shared</td>
									<td>1</td>
								</tr>
								<tr>
									<td>k</td>
									<td>I'm still shared</td>
									<td>2</td>
								</tr>
							</tbody>
						</table>
					</section>
					<section>
						<h3>Batch</h3>
						<p>
							Une requête "batch" permet de combiner de multiples INSERT, UPDATE et DELETE au sein d'une même opération logique:
						</p>
						<pre><code data-trim contenteditable>
BEGIN BATCH
INSERT INTO t (k, s, i) VALUES ('k', 'I''m shared', 1);
INSERT INTO t (k, s, i) VALUES ('k', 'I''m still shared', 2);
APPLY BATCH;
						</code></pre>
						<ul>
							<li>
								Un BATCH est atomique: si une requête échoue alors toutes les requêtes du BATCH échouent.
							</li>
							<li>
								Un BATCH n'est pas isolé: d'autres requêtes peuvent voir les données écritent par un batch en cours d'exécution.
							</li>
						</ul>
					</section>
					<section>
						<div class="github-fork-ribbon right-top" title="v2.1"></div>
						<h3>UDT: User Defined Type</h3>
						<p>
							Il est possible de déclarer dans C* des structures plus complexes. Par exemple si je souhaite gérer des listes d'adresses comment faire ?
						</p>
						<p>
							Deux possibilités:
						</p>
						<ol>
							<li>
								Déclarer une list<text> et mettre dans le texte notre adresse (sous forme de JSON par exemple)
							</li>
							<li>
								Utiliser un UDT afin de déclarer de manière explicite notre adresse
							</li>
						</ol>
					</section>
					<section>
							<div class="github-fork-ribbon right-top" title="v2.1"></div>
							<h3>UDT: User Defined Type</h3>
						<pre><code data-trim contenteditable>
CREATE TYPE address (
  street text,
  city text,
  zip int
);

CREATE TABLE user_profiles (
  login text PRIMARY KEY,
  first_name text,
  last_name text,
  email text,
  addresses map&lt;text, frozen&lt;address&gt;&gt;
);
					</code></pre>
				</section>
					<section>
							<div class="github-fork-ribbon right-top" title="v2.1"></div>
							<h3>UDT: User Defined Type</h3>
					<pre><code data-trim contenteditable>
// Inserts a user with a home address
INSERT INTO user_profiles(login, first_name, last_name, addresses)
VALUES ('tsmith', 'Tom', 'Smith',
  { 'home': { street: '1021 West 4th St. #202',
    city: 'San Fransisco',
    zip: 94110 }});

// Adds a work address for our user
UPDATE user_profiles
  SET addresses = addresses
  + { 'work': { street: '3975 Freedom Circle Blvd',
    city: 'Santa Clara',
    zip: 95050 }}
  WHERE login = 'tsmith';
						</code></pre>
					</section>
					<section>
						<div class="github-fork-ribbon right-top" title="v3.0"></div>
						<h3>Materialized View</h3>
						<p>
							Nous avons vu au début de cette partie que pour faire des requêtes sur des colonnes ne faisant pas partie de la clé de partitionnement <span class='highlight'>il fallait dénormaliser</span> et <span class='highlight'>créer des tables adaptées aux requêtes</span> que l'on souhaitaient faire. Les index secondaires ne sont pas la solution car ils ne sont pas suffisament performants.
						</p>
						<p>
							Cassandra 3 fournit un nouveau mécanisme appelé Materialized View qui est en fait une <span class='highlight'>dénormalisation effectuée automatiquement côté serveur</span>.
						</p>
					</section>
					<section>
						<div class="github-fork-ribbon right-top" title="v3.0"></div>
						<h3>Materialized View</h3>
						<p>
							Reprenons notre exemple initial: nous voulons pouvoir obtenir les informations de l'utilisateur en fonction de l'email de l'utilisateur et pas seulement depuis son id.
						</p>
						<pre><code data-trim contenteditable>
CREATE TABLE users (
  id UUID PRIMARY KEY,
  first_name TEXT,
  last_name TEXT,
  email TEXT
);

CREATE MATERIALIZED VIEW user_by_email
AS SELECT *  //denormalize ALL columns
FROM users
WHERE email IS NOT NULL AND id IS NOT NULL
PRIMARY KEY(email, id);
					</code></pre>
					</section>
					<section>
						<div class="github-fork-ribbon right-top" title="v3.0"></div>
						<h3>Materialized View</h3>
						<p>
							Il n'y a rien de particulier à faire ensuite, on insère les données normalement dans la table users et on peut lire les données depuis la vue user_by_email:
						</p>
						<pre><code data-trim contenteditable>
INSERT INTO users(id,first_name,last_name,email) VALUES(1, 'John', 'DOE', 'jdoe@gmail.com');
INSERT INTO users(id,first_name,last_name,email) VALUES(2, 'Helen', 'SUE', 'hsue@yahoo.com');

SELECT * FROM user_by_email;
					</code></pre>
					<table>
						<thead>
							<tr>
								<th>email</th>
								<th>id</th>
								<th>first_name</th>
								<th>last_name</th>
							</tr>
						</thead>
						<tbody>
							<tr>
								<td>jdoe@gmail.com</td>
								<td>1</td>
								<td>'John'</td>
								<td>'DOE'</td>
							</tr>
							<tr>
								<td>hsue@yahoo.com</td>
								<td>2</td>
								<td>'Helen'</td>
								<td>'SUE'</td>
							</tr>
						</tbody>
					</table>
					</section>
					<section>
						<h3>Et bien plus...</h3>
						<p>
							Il est possible de faire encore bien plus avec le CQL (UDF, UDA, tuples, ...).
						</p>
						<p>
								Pour plus d'informations une <a href="https://docs.datastax.com/en/cql/3.3/cql/cqlIntro.html">documentation très complète est disponible</a>.
						</p>
					</section>
				</section>

				<section>
					<section>
						<h1>Créer une application Java scalable</h1>
					</section>
				</section>

				<section>
					<section>
						<h1>Préparer Cassandra pour la production</h1>
					</section>
					<section>
						<h3>Stratégies de réplication</h3>
						<p>SimpleStrategy, NetworkTopologyStrategie</p>
					</section>
					<section>
						<h3>Stratégies de compaction</h3>
					</section>
					<section>
						<h3>Query Tracing</h3>
					</section>
					<section>
						<h3>Authentification et Autorisation</h3>
					</section>
				</section>

				<section>
					<section>
						<h1>Merci !</h1>
					</section>
				</section>

			</div>

		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				slideNumber: 'c / t',
				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
